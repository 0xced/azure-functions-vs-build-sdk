<!--
***********************************************************************************************
Microsoft.NET.Sdk.Functions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Import Sdk="Microsoft.NET.Sdk.Publish" Project="Sdk.targets" />

  <ItemGroup>
    <ProjectCapability Include="AzureFunctions"/>
  </ItemGroup>
  
  <PropertyGroup>
    <_FunctionsTaskFramework Condition=" '$(MSBuildRuntimeType)' == 'Core'">netstandard1.5</_FunctionsTaskFramework>
    <_FunctionsTaskFramework Condition=" '$(_FunctionsTaskFramework)' == ''">net46</_FunctionsTaskFramework>
    <_FunctionsTasksDir Condition=" '$(_FunctionsTasksDir)'=='' ">$(MSBuildThisFileDirectory)..\..\tools\$(_FunctionsTaskFramework)\</_FunctionsTasksDir>
    <_FunctionsTaskAssemblyFullPath Condition=" '$(_FunctionsTaskAssemblyFullPath)'=='' ">$(_FunctionsTasksDir)\Microsoft.NET.Sdk.Functions.dll</_FunctionsTaskAssemblyFullPath>
    <DebugSymbols Condition="'$(DebugSymbols)' == ''">true</DebugSymbols>
    <DebugType Condition="'$(DebugType)' == ''">pdbonly</DebugType>
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <UsingTask TaskName="BuildFunctions" AssemblyFile="$(_FunctionsTaskAssemblyFullPath)"/>
  

  <!--********************************************************************-->
  <!-- This target gets called after Build for generating 
       function.json for all functions in the project                     -->
  <!--********************************************************************-->
  <Target Name="_GenerateFunctionsBuildArtifacts" 
          AfterTargets="Build" 
          Condition="'$(DeployOnBuild)' != 'true'">

    <PropertyGroup>
        <GenerateHostJson Condition="'$(GenerateHostJson)' == ''">true</GenerateHostJson>
    </PropertyGroup>
    
    <ConvertToAbsolutePath Paths="$(OutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="OutputFullPath"/>
    </ConvertToAbsolutePath>
    
    <BuildFunctions
      TargetPath="$(TargetPath)"
      OutputPath="$(OutputFullPath)"
      GenerateHostJson="$(GenerateHostJson)"/>
  </Target>
  
  <!--********************************************************************-->
  <!-- This target gets called during folder publish from VS since 
       Function project is a class library project rather than
       a console project. IsPakable property for the functions projects
       is set to false, so, pack target wont pack the project. This target
       invokes the publish target to do the actual publish.
                                                                          -->
  <!--********************************************************************-->
  <Target Name="_FunctionsPackDependsOnPublish" 
          AfterTargets="Pack"
          DependsOnTargets="Publish" />

  <!--********************************************************************-->
  <!-- This target gets called after every publish target to generate the 
       function.json for the functions present in the project.
                                                                          -->
  <!--********************************************************************-->
  <Target Name="_FunctionsPublish" 
          AfterTargets="Publish"
          Condition="'$(DeployOnBuild)' != 'true'">
    
     <PropertyGroup>
        <GenerateHostJson Condition="'$(GenerateHostJson)' == ''">true</GenerateHostJson>
    </PropertyGroup>
    
    <ConvertToAbsolutePath Paths="$(PublishDir)">
      <Output TaskParameter="AbsolutePaths" PropertyName="PublishDirFullPath"/>
    </ConvertToAbsolutePath>

    <PropertyGroup>
      <ApplicationDllName Condition="'$(ApplicationDllName)' == ''">$([System.IO.Path]::GetFileName($(TargetPath)))</ApplicationDllName>
      <PublishTargetPath Condition="'$(PublishTargetPath)' == ''">$(PublishDirFullPath)\$(ApplicationDllName)</PublishTargetPath>
    </PropertyGroup>
    
    <BuildFunctions
      TargetPath="$(PublishTargetPath)"
      OutputPath="$(PublishDirFullPath)"
      GenerateHostJson="$(GenerateHostJson)"/>
  </Target>
  
  <!--********************************************************************-->
  <!-- This target gets called when publish is invoked with DeployOnBuild
       set. This target is responsible for overriding the publish targets
       from Publish SDK and generating function.json during publish.
                                                                          -->
  <!--********************************************************************-->
  <PropertyGroup>
    <CorePublishDependsOn>
      _InitPublishBinDirectory;
      Publish;
      _GenerateFunctionsPublishArtifacts;
      $(_DotNetPublishFiles);
    </CorePublishDependsOn>
  </PropertyGroup>
  
  <Target Name="_InitPublishBinDirectory" >
    <PropertyGroup>
      <PublishDir>$(PublishIntermediateOutputPath)</PublishDir>
    </PropertyGroup>

    <!-- Remove all the files from the temp directory first-->
    <ItemGroup>
      <_PublishTempFiles Include="$(PublishIntermediateOutputPath)**\*.*" />
    </ItemGroup>

    <Delete Files="@(_PublishTempFiles)" ContinueOnError="true" />
    <RemoveDir Directories="$(PublishIntermediateOutputPath)" ContinueOnError="true" Condition="Exists('$(PublishIntermediateOutputPath)')" />
    <MakeDir Directories="$(PublishIntermediateOutputPath)" Condition="!Exists('$(PublishIntermediateOutputPath)')"/>
  </Target>
  
  
  <!--********************************************************************-->
  <!-- This target generates the function.json for functions
                                                                          -->
  <!--********************************************************************-->
  <Target Name="_GenerateFunctionsPublishArtifacts">
    <PropertyGroup>
      <ApplicationDllName Condition="'$(ApplicationDllName)' == ''">$([System.IO.Path]::GetFileName($(TargetPath)))</ApplicationDllName>
      <PublishTargetPath Condition="'$(PublishTargetPath)' == ''">$(PublishDir)\$(ApplicationDllName)</PublishTargetPath>
    </PropertyGroup>
    
    <BuildFunctions
      TargetPath="$(PublishTargetPath)"
      OutputPath="$(PublishIntermediateOutputPath)"/>
  </Target>

  <!--********************************************************************-->
  <!-- CopyLocalLockFileAssemblies does not copy all the required assemblies 
       to the TargetDir folder. This target will copy all the required files
       to the TargetDir folder.
                                                                          -->
  <!--********************************************************************-->

  <Target
   Name="ResolveAdditionalReferenceCopyLocalPathsForFunctions"
   DependsOnTargets="RunResolvePublishAssembliesForFunctions"
   AfterTargets="ResolveReferences"
     >

    <!--
      Copy publish assemblies that not already included in ReferenceCopyLocalPaths
      via CopyLocalLockFileAssemblies=true. This will include RID-specific assets 
      that would be published in  the runtimes/ folder, but excluded from 
      CopyLocalLockFileAssemblies when no RuntimeIdentifier is set.
    -->
    <ItemGroup Condition="'$(RuntimeIdentifier)' == ''">
      <!-- 
       NOTE: The exclusion here is to ensure that we do not override any existing 
             ReferenceCopyLocalPaths with assets from RunResolvedPublishAssemblies.
             The ReferenceCopyLocalPaths can have conflicts resolved that are not 
             also resolved in the publish set, and publish currently relies on copy
             local paths having precedence over it to ensure conflict resolution 
             applies. We must preserve that precedence here.
     -->
      <_RidSpecificAssembliesByDestination
        Include="@(ResolvedAssembliesToPublish->'%(DestinationSubPath)')"
        Exclude="@(ReferenceCopyLocalPaths->'%(DestinationSubDirectory)%(Filename)%(Extension)')"
        OriginalItemSpec="%(ResolvedAssembliesToPublish.Identity)"
       />

      <_RidSpecificAssembliesByDestination
        DestinationSubDirectory="%(_RidSpecificAssembliesByDestination.RelativeDir)"
       />

      <ReferenceCopyLocalPaths
        Include="@(_RidSpecificAssembliesByDestination->'%(OriginalItemSpec)')"
        Exclude="@(ReferenceCopyLocalPaths)"
       />
    </ItemGroup>

    <!--
       Copy reference assemblies needed for runtime compilation to refs/ folder. Only 
       those that are not a also runtime assemblies and therefore already included in 
       ReferenceCopyLocalPaths via CopyLocalLockFileAssemblies=true are needed.
      -->
    <ItemGroup Condition="'$(PreserveCompilationContext)' == 'true'">
      <ReferenceCopyLocalPaths
        Include="@(ReferencePath)"
        Exclude="@(ReferenceCopyLocalPaths)"
        DestinationSubDirectory="$(RefAssembliesFolderName)\"
        />
    </ItemGroup>

  </Target>

  <!-- 
     We only need to call RunResolvePublishAssemblies during build when we do not 
     have a RuntimeIdentifier.Otherwise, we already have everything we need from
     CopyLocalLockFileAssemblies.
   -->
  <Target
    Name="RunResolvePublishAssembliesForFunctions"
    Condition="'$(RuntimeIdentifier)' == ''"
    DependsOnTargets="RunResolvePublishAssemblies"
  />

  <!-- 
     CLean should delete all the generated Content.
   -->
  <Target
    Name="CleanupTargetDir"
    AfterTargets="Clean">

    <ItemGroup>
      <_FilesInTargetDir Include="$(TargetDir)\**\*" />
    </ItemGroup>

    <Delete Files="@(_FilesInTargetDir)" ContinueOnError="true" />
    <RemoveDir Directories="$(TargetDir)" ContinueOnError="true" />  
  </Target>
  
</Project>
